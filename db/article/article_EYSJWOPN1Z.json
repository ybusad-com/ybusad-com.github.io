{"code":0,"msg":"ok","data":{"article":{"authorCode":"admin","authorName":"孙天骁","classify":"技术类","content":"<p>\t\t最近开始学习Docker，为未来的骁之屋的架构做技术储备。什么是Docker？Docker是一种虚拟化技术。它可以在一台机器上部署多个互相不影响的容器，每个容器提供预设好的运行环境来运行应用。相比虚拟机来说，Docker启动速度快，占用资源少，且比虚拟机还要更方便移植。下面我来谈一谈怎样使用Docker来搭建一个简单的Nginx+PHP运行环境。</p><p>\t\t为了这个简单的运行环境。我们需要两个容器。一个运行Nginx，一个运行PHP。Nginx用于启动http服务，支持https，将符合条件的请求转交给PHP处理。PHP处理之后再返回给用户。这就是一个简单的思路。为了构建这两个容器，我们需要两个镜像。在Docker Hub官方仓库里，有许许多多标准的镜像。例如提供Nginx的镜像。我们要做的事情，就是在官方镜像上加以配置，来构建一个属于自己的镜像。</p><p>\t\t怎样构建一个包含了自己的配置的镜像呢？这个就需要dockerfile出场了。dockerfile是一个docker镜像的构建配置文件。在这个文件里，我们可以有许许多多的命令，在一个来自Docker Hub或其他镜像源的镜像上进行修改，然后构建出一个属于自己的镜像。我们先谈PHP镜像。PHP镜像比较简单。只需要使用官方的php-fpm镜像。在这个镜像的基础上，加入一个自己的php.ini配置文件，它启动之后，就会默认监听9000端口。</p><p>\t\t首先令我的php.ini文件出场：</p><pre class=\"ql-syntax\" spellcheck=\"false\">#php.ini\n\nmax_execution_time = 50\ndisplay_errors = Off\nupload_max_filesize = 30M\nmax_file_uploads = 20\nallow_url_fopen = On\ndate.timezone = Asia/Shanghai\n</pre><p>\t\t如果想要这个php.ini生效，那就需要把它复制到php镜像中的 /usr/local/etc/php/conf.d目录下。因此我的dockerfile是这样写的：</p><pre class=\"ql-syntax\" spellcheck=\"false\">#dockerfile\n\nFROM php:7.1.10-fpm\nCOPY ./php.ini /usr/local/etc/php/conf.d/php.ini\nEXPOSE 9000\n</pre><p>\t\t我来解释一下这三行的意思。</p><p>\t\t第一行：FROM php:7.1.10-fpm。意思是该镜像基于官方的php:7.1.10-fpm镜像。php有多种可以和Web Server耦合的方式。常常使用fastcgi的方式来配合nginx。所以就需要这个fpm（<span style=\"color: rgb(34, 34, 34);\">FastCGI Process Manager</span>）镜像。</p><p>\t\t第二行：COPY ./php.ini /usr/local/etc/php/conf.d/php.ini。意思将dockerfile所在目录下的php.ini文件拷贝到镜像的/usr/local/etc/php/conf.d目录下。镜像可以看做是一个完整的linux操作系统。这个php镜像是基于debian操作系统的。</p><p>\t\t第三行：EXPOSE 9000。声明这个镜像需要暴露出9000端口。当然声明了这一行，也不会为你自动绑定端口。还是需要你手动绑定端口才行。</p><p>\t\t接下来我们配置nginx镜像。nginx镜像需要一个nginx配置文件，两个https密钥文件。因此我的dockerfile是这样写的。</p><pre class=\"ql-syntax\" spellcheck=\"false\">#dockerfile\n\nFROM nginx:1.17.2-alpine\nCOPY ./cert /etc/nginx/cert\nCOPY ./nginx.conf /etc/nginx/conf.d/default.conf\nEXPOSE 80 443\n</pre><p>\t\t这个dockerfile一共四行。我来解释一下。</p><p>\t\t第一行：FROM nginx:1.17.2-alpine。表示该镜像基于nginx:1.17.2-alpine这个镜像。alpine是一个体积迷你的linux发行版。基于alpine的镜像可以大幅度减小镜像的体积。</p><p>\t\t第二行：COPY ./cert /etc/nginx/cert。把dockerfile所在目录下的cert文件夹下的内容拷贝到镜像中的/etc/nginx/cert目录下。如果镜像中不存在这个目录，会自动新建，不必担心。</p><p>\t\t第三行：COPY ./nginx.conf /etc/nginx/conf.d/default.conf。将dockfile所在目录下的nginx.conf拷贝到镜像中的相应目录下。同时进行了一个重命名，命名成default.conf。在nginx的配置中，nginx会读取conf.d目录下面的配置文件来启动服务。</p><p>\t\t第四行：声明使用80和443端口。</p><p>\t\t下面来谈谈我的nginx配置文件是怎样写的。</p><pre class=\"ql-syntax\" spellcheck=\"false\">server {\n    listen 443;\n    server_name localhost;\n\n\n    ssl on;\n    ssl_certificate /etc/nginx/cert/ybusad.cer;\n    ssl_certificate_key /etc/nginx/cert/ybusad.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n    ssl_prefer_server_ciphers on;\n  \n    location / {\n        root   /usr/share/nginx/html;\n        index  index.php index.html index.htm;\n    }\n\n\n    error_page  404              /404.html;\n\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    location ~ \\.php$ {\n       root           /usr/share/nginx/html;\n       fastcgi_pass   172.18.0.1:9000;\n       fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;\n       include        fastcgi_params;\n    }\n}\n\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.php index.html index.htm;\n    }\n\n\n    error_page  404              /404.html;\n\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    location ~ \\.php$ {\n       root           /usr/share/nginx/html;\n       fastcgi_pass   172.18.0.1:9000;\n       fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;\n       include        fastcgi_params;\n    }\n}\n</pre><p>\t\t文件比较长，不过结构还是很简单的。如果是443端口的请求，则加载https证书，提供https服务。如果是80端口的请求，则提供普通的http服务。其他的配置两个是一样的。</p><p>\t\troot /usr/share/nginx/html; 这一行表示我们的网站文件在这个目录下。</p><p>\t\tindex index.php index.html index.htm; 这一行表示目录下的默认文件。当我们通过url直接访问一个目录时，nginx会优先寻找index.php的内容处理返回。如果index.php不存在，则寻找index.html，以此类推。</p><p>\t\t这个配置文件的重点在于转发php请求。主要在于fastcgi_pass和fastcgi_param这两行。</p><p>\t\tfastcgi_pass表示把匹配到php的请求交给哪个程序去处理。而fastcgi_param SCRIPT_FILENAME则是告诉目标程序需要处理的php文件所在的路径。</p><p>\t\t我将fastcgi_pass指向了172.18.0.1:9000。172.18.0.1是我的宿主机的ip地址。怎么拿到这个ip地址？在宿主机也就是docker所在的机器上运行如下代码：</p><pre class=\"ql-syntax\" spellcheck=\"false\">ip addr show docker0 | grep -Po 'inet \\K[\\d.]+'\n</pre><p>\t\t于是它就返回了如下内容：</p><pre class=\"ql-syntax\" spellcheck=\"false\">172.18.0.1\n</pre><p>\t\t为什么要这样搞呢，因为nginx容器想访问php容器时，必须要借助宿主机才行。因为这是两个独立的docker容器。具体参考 <a href=\"https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container\" target=\"_blank\">https://stackoverflow.com/questions/31324981/how-to-access-host-port-from-docker-container</a>，我觉得这一块还有优化的空间。</p><p>\t\tfastcgi_param SCRIPT_FILENAME的参数是以/var/www/html开头的，这个是个坑。为什么要这样写呢？因为两个容器启动的时候需要可以访问到同一份网站文件。下文启动的时候会把网站文件挂载到php容器的/var/www/html目录下，所以必须在nginx配置上这样写，才能让php容器正常找到相应的php文件。</p><p>\t\t在项目中新建一个public文件夹用于存放网站文件。新建一个nginx文件夹来存放nginx的配置和dockerfile。新建一个php文件夹来存放php的配置和dockerfile。我的整个项目目录结构如下所示：</p><pre class=\"ql-syntax\" spellcheck=\"false\">docker-php/\n|  +-- nginx/\n|  |  +-- cert/\n|  |  |  +-- ybusad.cer\n|  |  |  +-- ybusad.key\n|  |  +-- nginx.conf\n|  |  +-- dockerfile\n|  +-- php/\n|  |  +-- php.ini\n|  |  +-- dockerfile\n|  +-- public/\n|  |  +-- index.php\n|  +--.dockerignore\n|  +--.gitignore\n|  +--README.md\n</pre><p>\t\t将这个项目同步到服务器上，切到docker-php目录，开始构建镜像。</p><pre class=\"ql-syntax\" spellcheck=\"false\">docker build -t php-server-nginx ./nginx\ndocker build -t php-server-php ./php\n</pre><p>\t\t这就生成了两个自定义镜像，叫做php-server-nginx和php-server-php。</p><p>\t\t接着根据这两个镜像新建并启动容器。</p><pre class=\"ql-syntax\" spellcheck=\"false\">docker run -d -v $(pwd)/public:/var/www/html -p 9000:9000 php-server-php\ndocker run -d -v $(pwd)/public:/usr/share/nginx/html -p 80:80 -p 443:443 php-server-nginx\n</pre><p>\t\tdocker run就是根据镜像新建并启动容器的命令。启动容器之前需要保证相应的端口没有被占用。否则会报错，可以手动docker kill掉之前使用相应端口的容器。</p><p>\t\t讲一下docker run的启动参数。</p><p>\t\t-d 表示启动的容器将在后台运行，会在命令行输出启动的容器id。</p><p>\t\t-v 表示挂载。$(pwd)表示当前目录。意思是将当前目录下的public文件夹挂载到容器中的对应目录。容器内的应用访问对应目录时，实际上就是在访问宿主机上的public目录。这样两个容器就能访问到同一份网站文件。并且修改网站内的文件时，更改也会立即生效。</p><p>\t\t-p 绑定端口，冒号前的是本机的端口，冒号后的是容器内的端口。</p><p>\t\t最后的名字就是之前docker build -t指定的容器的名称了。</p><p>\t\t正常启动之后，使用docker ps命令，就能看到启动中的容器：</p><pre class=\"ql-syntax\" spellcheck=\"false\">CONTAINER ID&nbsp; &nbsp; &nbsp; &nbsp; IMAGE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CREATED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STATUS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PORTS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NAMES\na3e830e8d261&nbsp; &nbsp; &nbsp; &nbsp; php-server-nginx&nbsp; &nbsp; \"nginx -g 'daemon of…\"&nbsp; &nbsp;45 minutes ago&nbsp; &nbsp; &nbsp; Up 45 minutes&nbsp; &nbsp; &nbsp; &nbsp;0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp&nbsp; &nbsp;youthful_aryabhata\n497aedd4b65b&nbsp; &nbsp; &nbsp; &nbsp; php-server-php&nbsp; &nbsp; &nbsp; \"docker-php-entrypoi…\"&nbsp; &nbsp;13 hours ago&nbsp; &nbsp; &nbsp; &nbsp; Up 13 hours&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0.0.0.0:9000-&gt;9000/tcp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kind_snyder\n</pre><p>\t\t访问服务器绑定的域名时，就可以看到/public/index.php所运行的结果了。因为有做ssl配置，所以https访问也是可以的。</p><p>\t\t这些就是我的初步研究结果了。</p>","createTime":"2019-08-04 12:50:11","customCoverKey":"","id":245,"isGood":true,"isTop":false,"publicState":0,"replyCount":1,"state":0,"tags":["网站开发","php","docker"],"title":"使用Docker部署Nginx+PHP运行环境","urlCode":"EYSJWOPN1Z","viewCount":469,"viewGroup":-1,"authPassed":true},"author":{"exists":true,"name":"孙天骁","code":"admin","alias":"stx","description":"一个内心丰富的人","homepageUrl":"/u/stx","group":5,"groupName":"站长","isLocked":false,"gender":1,"avatarUrl":"/s/user/FufL-vSFO5eM1we1mxdfYHKH9tfK.jpg","realName":"孙天骁","refBaike":"","isManager":true,"isMe":true,"isLover":false,"introduction":"","joinTime":"2015-02-11 21:45:00"}}}