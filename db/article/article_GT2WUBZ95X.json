{"code":0,"msg":"ok","data":{"article":{"authorCode":"admin","authorName":"孙天骁","classify":"技术类","content":"<p>\t\t今年因为有了在互联网大厂工作的经历，所以我的技术水平得到了又一个大跨步的提升。那么技术提升的最终目标应该是体现在个人网站上，因此新一代骁之屋的研发又提上日程了！我给它起了一个代号，叫做“光辉号（splendor）”</p><p>\t\t在我自豪地介绍我目前的研发成果之前，还是先介绍一下骁之屋历史上几个重要的技术架构更新吧。我早期个人网站的技术架构是基于ASP.NET和Dreamweaver（2012-2014），后来学了一些前后端的知识，在2015年上半年完成了骁之屋第一次大技术更新，前端使用jQuery，后端使用原生php 5.x，使用medoo操作mysql数据库。网站的第二次技术革新完成于2018年中，前端使用Vue单页应用构建，后端使用ThinkPHP构建，前后端分离，支持https并运行在阿里云服务器上。这一版也是我写这篇文章现在正在服役的骁之屋。</p><p>\t\t而这一次我在规划“光辉号”骁之屋的时候，它的革新还要远超前两次。我现在也只规划了一部分而已，所以我现在只是来做一个初步的解析。“光辉号”骁之屋我现在已经完成的架构部分有：</p><ol><li>使用Go语言替代PHP作为后端语言，使用Gin+GORM作为Web和数据库框架。</li><li>加入Node中间层设计，使用有赞Astroboy框架，可以兼容新老前端并存。</li><li>使用docker做容器化部署，资源文件全部上云。外层使用Nginx反向代理提供https。</li><li>接入Redis做为缓存数据库。</li></ol><p><br></p><p>\t\t而我现在还没有规划结束和开始开发的部分有：</p><ol><li>前端架构，包括完全分离的桌面版和移动版、管理后台、小程序和App的规划。</li><li>接入ElasticSearch，提供模糊搜索支持。</li><li>自动化部署系统设计、网站具体功能点改进、周边生态建设。</li></ol><p><br></p><p>\t\t来分享一下我最近的一些积累吧。</p><p>\t\t一. Go语言后端部分</p><p>\t\t今年上半年我尝试写区块链智能合约的时候接触了Go语言，那个时候我100%没有想到会有一天我打算用Go语言来写我的个人网站。因为在之前的我看来，Go语言的语法很奇怪，各种规则限制得很死。和之前写PHP的时候区别太大了，让我很不适应。但后来到了有赞之后，我接触了各种各样的代码规范、格式化工具，以及学习使用了TypeScript，这时的我才更进一步发现强规范的好处。如果继续用PHP或者Node这样的弱类型语言写，肯定最后又会落入难于维护的境地。Java的话我嫌太啰嗦，所以Go确实是我最好的选择。</p><p>\t\t早期的Go没有统一的依赖包管理策略，到了Go 1.11，Go语言官方推出了Go Modules，结束了这一局面。我现在使用的Go语言版本是1.13，所以自然而然要用新的依赖包管理策略。但这其中还有一个坑，那就是官方的依赖包源在国内因为墙的限制基本无法访问。我们当然不能靠着翻墙来解决这个问题，这时就要用到Go的第三方依赖包源goproxy.io了，它起到了一个类似淘宝cnpm相对于npm的作用。我们需要在命令行中来一句：</p><pre class=\"ql-syntax\" spellcheck=\"false\">export GOPROXY=goproxy.io\n</pre><p>\t\t这样下载Go依赖包的时候就会从可以快速访问的源去下载了。</p><p>\t\t在Go Modules中，安装新依赖使用的命令是 go get，而下载所有依赖的命令是 go mod download。</p><p>\t\t下面再谈一谈我使用的Go Web框架 - Gin。我的初衷是只是为了找一个简单好用的Go API框架，所以我看到Gin简单快速的框架时，我就没有再犹豫过了。它给我的感觉就像Node的Express一样。但是在如何规划目录结构的时候，还是让我犹豫了很久。后来我参考了几个类似项目的目录规范，以及几个社区规范之后，我拿出了我的目录结构，应该不会有大的变动了：</p><pre class=\"ql-syntax\" spellcheck=\"false\">splendor-go\n|-- config       # 项目配置管理\n|-- controllers  # 控制器\n|   |-- home     # 功能目录\n|   |   |-- types  # 控制器中使用的数据模型定义\n|   |   |   |-- weather.go\n|   |   |-- weather.go\n|   |-- user     # 其他功能目录\n|\n|-- database     # 数据库连接\n|-- middlewares  # 中间件\n|-- models       # 数据库模型定义\n|-- router       # 路由定义\n|-- tests        # 测试相关\n|-- utils        # 公共工具函数\n|-- go.mod       # go modules 文件（还有一个go.sum类似yarn.lock）\n|-- main.go      # 编译入口文件\n</pre><p>\t\t在我写一些实验性代码时，最纠结的还是控制器代码的数据模型定义到底应该放在哪里。一开始我参照一些社区规范把这些定义放到一个一级目录-forms里，但是在forms里再划分子目录时就尴尬了。因为目录名也规定了里面代码命名空间的名字，我在控制器的weather.go里引forms里的定义时就会用到类似forms.home.WeatherResponse这样看着很长很奇怪的东西。所以我后来想不如在控制器功能目录里再独立一个types文件夹，这样我用的时候只需要写types.XXXX就可以了。</p><p>\t\t二. Node中间层部分</p><p>\t\tNode中间层也是我来公司之后才接触到的一个概念，我发现它真的很有用，解决了很多前端和后端融合过程中的痒点和痛点。我在规划光辉号骁之屋时，我预见到我需要相当长的时间才能做到完全替换网站现有功能的地步。所以这次我准备探索新老前端和新老技术栈的中间状态。因此我在Node中间层里做了判断，将v2开头的url折射到新的逻辑，非v2开头的url还是使用老的前端，走的老的PHP。中间层其实用koa这样的框架就可以搭起来，但我需要在koa上的一个更好的封装和约定，因此我还是使用了有赞开源的中间层框架Astroboy。这样的话也有一个好处，就是可以帮助我加强对公司中间层结构的一个理解，让我以后写Node的时候也能更得心应手。Astroboy框架（文档地址：<a href=\"https://astroboy-lab.github.io/astroboy/\" rel=\"noopener noreferrer\" target=\"_blank\">https://astroboy-lab.github.io/astroboy/</a>）已经有了一个约定的目录结构，通过约定的目录结构就可以很方便地搭建起一个应用了。Astroboy框架调试的时候需要配合astroboy-cli这一个脚手架。我在用的时候发现它在应用启动之后会运行一次npm outdated，打印有更新的依赖包。但是它里面有一个问题，明明是开源的框架，居然在里面用了公司的私有npm地址。。于是我想了一个办法，我在github上fork了一下，把错误的代码改一改，然后自己去npm发了一个包叫做astroboy-cli-sk。这个包就是我中间层御用的调试工具，这也让我看到了，以后我要进行前端开发的时候，说不定我会在npm发布更多自己的包，来方便自己使用。</p><p>\t\t在这段时间里，我不仅设计好了中间层和Go后端的通信方式，也实现了一些插件，给node中间层添加了七牛云访问能力、redis数据库访问能力、nunjucks模板解析能力，以及成功情况下和错误情况下返回数据格式的封装。我将前端打包结果上传七牛云，version存储在redis数据库里，通过node去读redis再把前端文件的路径通过nunjucks注入html返回回来，这样就完成了最基本的前端代码的提供方式。我没有让Node的服务直接对外可见，在服务器上，我架了一层Nginx，我相信这也是一个很有潜力的设计。这样我通过自行配置Nginx提供https，完成http对https的跳转，以后也可以根据域名不同来实现对不同服务的访问。比如以后我会把php服务也迁过来，Nginx匹配到域名之后，就直接交给php容器处理就好了。</p><p>\t\t三. Docker容器部署部分</p><p>\t\tdocker在很多有点技术实力的公司里也是一个香饽饽的存在，它解决了部署应用程序时环境的问题。docker官方仓库也有很多各种各样的镜像，各种常用服务器软件全部都有。当光辉号骁之屋的结构如此复杂的时候，容器化部署确实是我必须要做的一件事情。目前我的测试服务器上用到了六个容器，分别是Go后端容器、Node中间层容器、Redis容器、MySQL容器、Nginx容器，还有方便我管理数据库的phpMyAdmin容器。接下来我要解决的问题是，如何让容器间进行顺畅的链接。</p><p>\t\t最开始我实验是用--link的方式，--link会将另外一个容器的各种信息写入当前容器的环境变量里，然后容器去读环境变量来获取另外一个容器的地址等信息。但--link会污染环境变量，写法也很不优雅。实际上--link的方法已经被废弃了，现在我们使用docker network的方式，把几个容器放在同一个网络里面，容器可以通过另外一个容器设置的网络内alias来访问这个容器。这种方式就比较优雅了。首先我们应该通过docker network create来新建一个网络，我自己就建了一个叫做splendor的网络。在docker run的时候加入这个网络，并设置一个别名。比如我目前node中间层应用的docker run命令是这样设计的：</p><pre class=\"ql-syntax\" spellcheck=\"false\">docker run -d -p 8201:8201 --name splendor-node --net splendor --net-alias splendor-node --restart always splendor-node\n</pre><p>\t\t-d 表示创建的容器会在后台运行，-p是绑定端口，将容器内的应用程序所使用的端口映射到容器对外表现的端口，--name就是为容器起一个名字，--net就是该容器加入的网络，--net-alias就是该容器在该网络内的别名，--restart always令这个容器在意外终止时会自动重启。最后一个splendor-node则是镜像的名称，之前通过docker build已经build出了一个叫做splendor-node的镜像。</p><p>\t\t通过这样的方式，我的go容器、node容器、nginx容器就可以很方便地加入同一个网络了。我的redis容器和mysql容器是基于官方镜像，很早就开始运行了。可以通过docker network connect命令来让现有容器加入网络。另外通过docker network inspect命令，就可以看到一个network里都包含了哪些容器了。</p><p>\t\t在往服务器部署新代码的时候我还遇到了一个问题，就是每当你构建了一个新的镜像要启动新的容器时，如果不先把旧的容器下掉，就会遇到端口冲突导致新容器无法启动的问题。如果你为旧容器命了名还好，没命名的话你还要先docker ps一下看看旧容器的id。所以为了解放生产力，也是为了docker run时不用写那么长的命令，于是我就请Makefile出场了。在项目里添加了Makefile之后，就可以使用make命令来帮你做事情了。还是拿node中间层项目举例，我的Makefile是这样写的：</p><pre class=\"ql-syntax\" spellcheck=\"false\">NAME&nbsp;=&nbsp;splendor-node\n\nusage&nbsp;=&nbsp;\"\\n\\\nUsage:&nbsp;make&nbsp;[target]\\n\\n\\\nAvailable&nbsp;targets:\\n\\n\\\ninstall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装项目依赖\\n\\\ndev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动调试\\n\\\nstart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动调试\\n\\\ndocker-kill&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;终止并删除docker容器\\n\\\ndocker-build&nbsp;&nbsp;&nbsp;&nbsp;打包docker镜像\\n\\\ndocker-run&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建并启动一个docker容器\\n\\\ndocker-restart&nbsp;&nbsp;重启docker容器\\n\\\n\"\n\nusage:\n&nbsp;&nbsp;@echo&nbsp;$(usage)\n\ninstall:\n&nbsp;&nbsp;yarn\n\nstart:\n&nbsp;&nbsp;yarn&nbsp;start\n\ndev:\n&nbsp;&nbsp;yarn&nbsp;start\n\ndocker-kill:\n&nbsp;&nbsp;-docker&nbsp;kill&nbsp;$(NAME)\n&nbsp;&nbsp;-docker&nbsp;rm&nbsp;$(NAME)\n\ndocker-build:\n&nbsp;&nbsp;docker&nbsp;build&nbsp;-t&nbsp;$(NAME)&nbsp;.\n\ndocker-run:&nbsp;docker-kill\n&nbsp;&nbsp;docker&nbsp;run&nbsp;-d&nbsp;-p&nbsp;8201:8201&nbsp;--name&nbsp;$(NAME)&nbsp;--net&nbsp;splendor&nbsp;--net-alias&nbsp;$(NAME)&nbsp;--restart&nbsp;always&nbsp;$(NAME)\n\ndocker-restart:\n&nbsp;&nbsp;docker&nbsp;restart&nbsp;$(NAME)\n</pre><p>\t\t第一行的话，我就是先声明了这个仓库的名字，下面方便去用。然后我写了一个usage命令，这样你单纯地运行make命令的时候，就会找到第一个声明的这个usage命令把用法打印出来。@echo前面的@是一个防止回声的作用，避免make命令在执行之前先把命令本身打印出来。通过make install就可以安装依赖，make start或make dev都可以启动调试，在这个项目中yarn start背后是ast dev。docker-kill命令就是我写的可以终止旧容器的命令，前面打的一个中划线“-”是起到一个忽略错误的作用，这样如果旧容器不存在（报错）也可以继续执行下去。docker-build就是构建镜像，后面的那个“.”就是寻找当前目录的dockerfile文件里构建镜像。docker-run命令就是根据镜像新建容器并启动，它做了一个前置命令就是docker-kill。最后的docker-restart就是我写的一个可以重启容器的命令。</p><p>\t\t当然这个部署方式也不是完美的，今后我还要继续探索怎样去更好地去优化这个部署流程。以及我也需要开发一套工具帮助我更方便地上传资源文件到七牛云上了。</p><p><br></p><p>\t\t这次技术分享就到这里吧，欢迎大家有宝贵的意见和建议去提出。</p>","createTime":"2019-11-25 22:43:01","customCoverKey":"","id":249,"isGood":false,"isTop":false,"publicState":0,"replyCount":0,"state":0,"tags":["网站开发","网站建设","光辉号"],"title":"光辉号骁之屋架构初步解析","urlCode":"GT2WUBZ95X","viewCount":393,"viewGroup":-1,"authPassed":true},"author":{"exists":true,"name":"孙天骁","code":"admin","alias":"stx","description":"一个内心丰富的人","homepageUrl":"/u/stx","group":5,"groupName":"站长","isLocked":false,"gender":1,"avatarUrl":"/s/user/FufL-vSFO5eM1we1mxdfYHKH9tfK.jpg","realName":"孙天骁","refBaike":"","isManager":true,"isMe":true,"isLover":false,"introduction":"","joinTime":"2015-02-11 21:45:00"}}}