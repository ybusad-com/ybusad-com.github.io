{"code":0,"msg":"ok","data":{"article":{"authorCode":"admin","authorName":"孙天骁","classify":"技术类","content":"<p>\t\t前段时间，“光辉号”骁之屋新版随记系统开发中，需要继续完善已有的 splendor-pc-admin 项目（网站后台管理），这个项目是我在去年五一期间搭建起来的，是一个 React 项目。之前是作为一个单页应用出场的。但这个后台项目用单页面的模式去管理属于不同模块的管理页面，总觉得有些奇怪，而且不太方便做单个模块内部的多页面逻辑。因此，那就动手把它改成多页面的形式吧。</p><p>\t\t首先晒一下之前的 webpack 配置。之前是用 webpack 4 做的，这次也一并升级到 webpack 5。</p><pre>const path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nconst isDev = process.env.NODE_ENV === 'development';\nconst isProd = !isDev;\n\nmodule.exports = {\n  entry: {\n    main: ['@babel/polyfill', './src/main.tsx'],\n  },\n  output: {\n    filename: '[name]-[hash:4].js',\n    path: path.resolve('./dist'),\n  },\n  devServer: {\n    contentBase: path.join(__dirname, 'public'),\n    historyApiFallback: true,\n    host: 'admin-new.sun.me',\n    proxy: {\n      '/v2': 'http://dev.sun.me',\n    },\n    compress: true,\n    port: 8990,\n    hot: true,\n  },\n  resolve: {\n    alias: {\n      api: path.resolve(__dirname, './src/api'),\n      components: path.resolve(__dirname, './src/components'),\n      common: path.resolve(__dirname, './src/common'),\n      pages: path.resolve(__dirname, './src/pages'),\n    },\n    extensions: ['.ts', '.tsx', '.js', '.jsx'],\n  },\n  module: {\n    rules: [\n      {\n        test: /(\\.jsx?|\\.tsx?)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n      {\n        test: (mod) =&gt; mod.endsWith('.scss') &amp;&amp; !mod.endsWith('.m.scss'),\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n            options: {\n              hmr: isDev,\n            },\n          },\n          'css-loader',\n          'sass-loader',\n        ],\n      },\n      // 为 .m.scss 结尾的文件开启 css module\n      {\n        test: (mod) =&gt; mod.endsWith('.m.scss'),\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n            options: {\n              hmr: isDev,\n            },\n          },\n          {\n            loader: 'css-loader',\n            options: {\n              modules: {\n                localIdentName: '[local]--[hash:base64:5]',\n              },\n            },\n          },\n          'sass-loader',\n        ],\n        exclude: [path.resolve(__dirname, 'node_modules')],\n      },\n      {\n        test: /\\.css$/,\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n            options: {\n              hmr: isDev,\n            },\n          },\n          'css-loader',\n        ],\n      },\n    ],\n  },\n  plugins: [\n    new MiniCssExtractPlugin(),\n    new HtmlWebpackPlugin({\n      template: 'template-index.html',\n      hash: false,\n      inject: false,\n    }),\n    new webpack.DefinePlugin({\n      isProd: isProd,\n      isDev: !isProd,\n    }),\n  ],\n};\n\nif (isProd) {\n  module.exports.plugins.push(...[new CleanWebpackPlugin()]);\n} else {\n  module.exports.devtool = 'source-map';\n}\n</pre><p><br></p><p>\t\t首先，@babel/polyfill 这个包过时了，官方文档说应该使用 core-js 和 regenerator-runtime 替代。那第一步先 yarn remove @babel/polyfill，然后再 yarn add core-js regenerator-runtime。再运行一下 yarn outdated 看一下有新版本的包，能升的都升一下。包括了 webpack 5。将 .babelrc 的 @babel/preset-env 的配置添加 useBuiltIn 和 corejs 配置。useBuiltIn 是 entry，corejs 的 version 是 3。</p><p>\t\t需要注意 webpack-dev-server 应该升级到 4.x 的 beta 版本。这个版本在 next 标签下，beta 版才是适配 webpack 5 的。然后根据 webpack-dev-server 在 github 上的 release 说明，更新一下用法。它的 break change 还是挺多的，不改的话运行会报错。比如说把 contentBase 选项改成 static 选项。</p><p>\t\t然后思考一下我们要干什么。做多页应用，把 src/pages 文件夹下面的一级目录内的 main.tsx 挑出来，把它作为多页应用中每个单页应用的入口。那我们要写一段脚本去做这个事情。</p><pre>const fs = require('fs');\nconst path = require('path');\n\nfunction scanEntries() {\n  const resultEntries = {};\n  const dirs = fs.readdirSync(path.resolve(__dirname, '../src/pages'));\n  for (const dir of dirs) {\n    const fullPath = path.resolve(__dirname, '../src/pages', dir);\n    const fstats = fs.statSync(fullPath);\n    if (fstats.isDirectory()) {\n      const files = fs.readdirSync(fullPath);\n      for (const file of files) {\n        if (/^main.tsx?$/.test(file)) {\n          resultEntries[dir] = `./src/pages/${dir}/${file}`;\n        }\n      }\n    }\n  }\n  return resultEntries;\n}\n\nmodule.exports = scanEntries;\n</pre><p>\t\t然后就可以改一下 webpack.config.js 的 entry，改成 scanEntries()。再同时改一下 output，就是要根据打出的每个 chunk（包）的名称来规定打包结果的存放位置。</p><pre>  entry: scanEntries(),\n  output: {\n    filename: (pathData) =&gt; {\n      return pathData.chunk.name === 'dashboard'\n        ? '[name]-[chunkhash:4].js'\n        : '[name]/[name]-[chunkhash:4].js';\n    },\n    path: path.resolve('./dist'),\n  },\n</pre><p>\t\t对于CSS来说，我使用了 MiniCssExtractPlugin 来生成单独的 CSS 文件，同样阅读这个插件的文档可知可以修改 filename 选项在不同地方生成每个包不同的 css 文件。我对 dashboard（仪表盘）这个 chunk 做了特殊判断，是希望它是一个首页的位置。filename 里使用的 chunkhash 是代表打包结果的每个包的整体hash值。如果换成 [hash] 的话就会变成所有包的整体 hash 值。这样的话哪怕我只改了其中某一个包，打包结果的文件名都会变，这样是不利于缓存的。用 chunkhash 就可以让没有改动的包打包结果的文件名也不变，利于缓存。</p><pre>  plugins: [\n    new MiniCssExtractPlugin({\n      filename: (pathData) =&gt; {\n        if (isProd) {\n          return pathData.chunk.name === 'dashboard'\n            ? '[name]-[chunkhash:4].css'\n            : '[name]/[name]-[chunkhash:4].css';\n        } else {\n          return pathData.chunk.name === 'dashboard' ? '[name].css' : '[name]/[name].css';\n        }\n      },\n    }),\n    ...getHtmlPluginConfig(),\n    new webpack.DefinePlugin({\n      isProd: isProd,\n      isDev: !isProd,\n      buildTime: Date.now(),\n    }),\n  ],\n</pre><p>\t\t接着需要编写一个 getHtmlPluginConfig 函数，是用来生成 HtmlWebpackPlugin 配置的。这个是根据打包结果生成 html 入口的插件。之前单页应用的时候，只要写一个配置就行。现在肯定是有多少 chunk，就要有多少个实例去生成多少个html入口。</p><pre>const HtmlWebpackPlugin = require('html-webpack-plugin');\nconst scanEntries = require('./scan-entries');\n\nfunction getHtmlPluginConfig() {\n  const resultEntries = scanEntries();\n  const chunks = Object.keys(resultEntries);\n  const res = [];\n  for (const chunk of chunks) {\n    res.push(\n      new HtmlWebpackPlugin({\n        template: 'template-index.html',\n        filename: chunk === 'dashboard' ? 'index.html' : `${chunk}/index.html`,\n        publicPath: '/',\n        chunks: [chunk],\n        minify: false,\n      })\n    );\n  }\n  return res;\n}\n\nmodule.exports = getHtmlPluginConfig;\n</pre><p>\t\t对于 devServer 来说，改成多页之后，history api的 fallback 行为要调整。让每个文件夹下面的逻辑页面单独适用当前所在文件夹的 index.html。因此还要编写一个 getFallback 函数，将调用结果赋给 devServer.historyApiFallback。</p><pre>const fs = require('fs');\nconst path = require('path');\n\nfunction getFallback() {\n  let dirs = fs.readdirSync(path.resolve(__dirname, '../src/pages'));\n  dirs = dirs.filter((dir) =&gt; {\n    const fullPath = path.resolve(__dirname, '../src/pages', dir);\n    const fstats = fs.statSync(fullPath);\n    return fstats.isDirectory();\n  });\n\n  return {\n    rewrites: [\n      ...dirs.map((dir) =&gt; {\n        return {\n          from: new RegExp(`^/${dir}/.*`),\n          to: `/${dir}/index.html`,\n        };\n      }),\n      { from: /.*/, to: '/index.html' },\n    ],\n  };\n}\n\nmodule.exports = getFallback;\n</pre><p><br></p><p>\t\t接下来再考虑一个事情。我们的每个包都引用了 react 这样的公共库。如果不做处理的话，会不会打出的每一个包都会把 react 打进去呢？这样很明显是不利于网络传输的，我们需要有打出公共chunk的能力，把不同包引用的相同部分都给抽去单独的文件里。这样在多个页面之间穿梭只需要加载一次公共代码部分就可以了。</p><p>\t\t于是我们需要配置 optimization 选项，基本用官方文档上的示例配置就可以。（<a href=\"https://webpack.js.org/plugins/split-chunks-plugin/\" target=\"_blank\">https://webpack.js.org/plugins/split-chunks-plugin/</a>）</p><pre>  module.exports.optimization = {\n    minimize: false,\n    minimizer: [new TerserPlugin()],\n    splitChunks: {\n      chunks: 'initial',\n      minSize: 20000,\n      minRemainingSize: 0,\n      minChunks: 1,\n      maxAsyncRequests: 30,\n      maxInitialRequests: 30,\n      enforceSizeThreshold: 50000,\n      cacheGroups: {\n        defaultVendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10,\n          reuseExistingChunk: true,\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n  };\n</pre><p><br></p><p>\t\t最后，改好的 webpack.config.js 是这样的：</p><pre>const path = require('path');\nconst webpack = require('webpack');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\nconst scanEntries = require('./utils/scan-entries');\nconst getHtmlPluginConfig = require('./utils/get-html-plugin-config');\nconst getFallback = require('./utils/get-fallback');\n\nconst isDev = process.env.NODE_ENV === 'development';\nconst isProd = !isDev;\n\nmodule.exports = {\n  mode: isDev ? 'development' : 'production',\n  target: ['web'],\n  entry: scanEntries(),\n  output: {\n    filename: (pathData) =&gt; {\n      return pathData.chunk.name === 'dashboard'\n        ? '[name]-[chunkhash:4].js'\n        : '[name]/[name]-[chunkhash:4].js';\n    },\n    path: path.resolve('./dist'),\n  },\n  devServer: {\n    static: [path.join(__dirname, 'public')],\n    historyApiFallback: getFallback(),\n    host: 'admin-new.sun.me',\n    proxy: {\n      '/v2': 'http://dev.sun.me',\n    },\n    compress: true,\n    port: 8990,\n    // writeToDisk: true,\n    hot: true,\n  },\n  resolve: {\n    alias: {\n      api: path.resolve(__dirname, './src/api'),\n      components: path.resolve(__dirname, './src/components'),\n      common: path.resolve(__dirname, './src/common'),\n      pages: path.resolve(__dirname, './src/pages'),\n    },\n    extensions: ['.ts', '.tsx', '.js', '.jsx'],\n  },\n  module: {\n    rules: [\n      {\n        test: /(\\.jsx?|\\.tsx?)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n      {\n        test: (mod) =&gt; mod.endsWith('.scss') &amp;&amp; !mod.endsWith('.m.scss'),\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n          },\n          'css-loader',\n          'sass-loader',\n        ],\n      },\n      // 为 .m.scss 结尾的文件开启 css module\n      {\n        test: (mod) =&gt; mod.endsWith('.m.scss'),\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n          },\n          {\n            loader: 'css-loader',\n            options: {\n              modules: {\n                localIdentName: '[local]--[hash:base64:5]',\n              },\n            },\n          },\n          'sass-loader',\n        ],\n        exclude: [path.resolve(__dirname, 'node_modules')],\n      },\n      {\n        test: /\\.css$/,\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n          },\n          'css-loader',\n        ],\n      },\n    ],\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: (pathData) =&gt; {\n        if (isProd) {\n          return pathData.chunk.name === 'dashboard'\n            ? '[name]-[chunkhash:4].css'\n            : '[name]/[name]-[chunkhash:4].css';\n        } else {\n          return pathData.chunk.name === 'dashboard' ? '[name].css' : '[name]/[name].css';\n        }\n      },\n    }),\n    ...getHtmlPluginConfig(),\n    new webpack.DefinePlugin({\n      isProd: isProd,\n      isDev: !isProd,\n      buildTime: Date.now(),\n    }),\n  ],\n};\n\nif (isProd) {\n  module.exports.optimization = {\n    minimize: false,\n    minimizer: [new TerserPlugin()],\n    splitChunks: {\n      chunks: 'initial',\n      minSize: 20000,\n      minRemainingSize: 0,\n      minChunks: 1,\n      maxAsyncRequests: 30,\n      maxInitialRequests: 30,\n      enforceSizeThreshold: 50000,\n      cacheGroups: {\n        defaultVendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10,\n          reuseExistingChunk: true,\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n  };\n  module.exports.plugins.push(...[new CleanWebpackPlugin()]);\n} else {\n  module.exports.devtool = 'source-map';\n}\n</pre><p>\t\t配置文件的改动之外，别忘了修改 pages 下每个页面的入口逻辑。拿掉以前的index.tsx，改成main.tsx。以随记模块为例，main.tsx可以这样写：</p><pre>import 'core-js/stable';\nimport 'regenerator-runtime/runtime';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport AppFrame from 'components/app-frame';\nimport App from './App';\n\nReactDOM.render(&lt;AppFrame app={App} /&gt;, document.getElementById('app'));\n</pre><p>\t\t最后还要改动一下 nginx 的 url 重写能力，这样线上才可以支持 history api fallback！例如随记模块就是这样：</p><pre>    location /essay/ {\n        root   /usr/share/nginx/admin;\n        index  index.html index.htm;\n\n        try_files $uri $uri/ /essay/index.html;\n\n        break;\n    }\n</pre><p>\t\t以上就是全部改动要点了。随着光辉号骁之屋的改造进程继续，到明年上半年的时候，应该就可以结束新老技术栈混用的局面了。整个骁之屋就会变得前所未有的清爽和功能强大。</p>","createTime":"2021-06-01 17:29:35","customCoverKey":"","id":294,"isGood":false,"isTop":false,"publicState":0,"replyCount":0,"state":0,"tags":["网站开发"],"title":"Webpack 项目的多页应用改造","urlCode":"multi-page-admin","viewCount":267,"viewGroup":-1,"authPassed":true},"author":{"exists":true,"name":"孙天骁","code":"admin","alias":"stx","description":"一个内心丰富的人","homepageUrl":"/u/stx","group":5,"groupName":"站长","isLocked":false,"gender":1,"avatarUrl":"/s/user/FufL-vSFO5eM1we1mxdfYHKH9tfK.jpg","realName":"孙天骁","refBaike":"","isManager":true,"isMe":true,"isLover":false,"introduction":"","joinTime":"2015-02-11 21:45:00"}}}